---
title: "QuickStart with Streamlined Workflow"
package: SigFun
output:
  BiocStyle::html_document:
    toc: true
    toc_depth: 3
    number_sections: true
date: "`r Sys.Date()`"
vignette: >
  %\VignetteIndexEntry{QuickStart}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r style, echo=FALSE, results='asis'}
BiocStyle::markdown(css.files = c('custom.css'))
knitr::opts_chunk$set(collapse=TRUE, comment="#>")
```

# Introduction

Multi-gene signatures are increasingly used in precision medicine to capture complex biological processes and predict patient outcomes. Yet interpreting what a signature actually represents at the functional level remains difficult. Most existing tools are designed for analyzing ranked genes lists or differential expression results, not for directly evaluating a multi-gene signature across a transcriptome. As a result, researchers often fall back on arbitrary sample stratification (e.g., high vs. low groups) or indirect proxies, which can obscure the biology driving a signature's predictive power.

**SigFun** was developed to bridge the gap between signature-based analyses and functional interpretation. Instead of requiring users to reshape their data into differential contrasts, SigFun directly computes genome-wide associations between a user-defined signature score (numeric or binary) and every gene in the transcriptome, linking those associations to biological functions.

The package supports both continuous and binary signatures, applying correlation methods (Spearman, Pearson, or Kendall) or logistic regression as appropriate. This adaptive modeling framework allows users to explore signatures from multiple perspectives—ranking genes by association strength, effect size, variability, clinical relevance, or custom-defined metrics—to reveal richer, context-specific biological insights.

To streamline interpretation, SigFun provides twelve integrated visualization tools, including heatmaps, network diagrams, ridge plots, and tree-based representations. These plots operate directly on analysis outputs, making the workflow from calculation to interpretation seamless and publication-ready. Built on the **SummarizedExperiment** framework, SigFun integrates naturally with Bioconductor workflows, enabling users to move efficiently from upstream data processing to signature interpretation without additional data formatting.

**Key Features Summary**

**SigFun** provides a comprehensive framework for interpreting multi-gene signatures through three core capabilities:

1.  **Adaptive association modeling:** Automatically calculates genome-wide gene-signature associations using the appropriate statistical method - correlation-based approaches for continuous signatures or logistic regression for binary classifications.
2.  **Multi-dimensional gene prioritization:** Stores all association metrics in a structured table (`cor.df`) that users can extend with custom rankings (e.g., effect sizes, variability measures, clinical hazard ratios), enabling exploration of signature function from multiple biological perspectives.
3.  **Integrated visualization ecosystem:** Offers 12 specialized plotting functions that translate enrichment results into publication-ready figures, supporting diverse analytical needs from pathway networks to distribution comparisons. See the *Visualization Functions vignette* for more details.
4.  **Standard workflow**: Built on SummarizedExperiment for seamless integration with Bioconductor ecosystem.

**Note: This QuickStart vignette also demonstrates the *streamlined workflow* (one-call `sig2Fun`) so you can see the fastest path from inputs to interpretable functions.**

# Vignettes at a Glance

-   **QuickStart with Streamlined Workflow** (`sig2Fun`)- Minimal working example *and* a demonstration of the streamlined `sig2Fun` workflow using built-in test data. *Start here to verify installation and understand the basic workflow.*

-   **Data Preparation** - How to build the required `SummarizedExperiment`: expression, `rowData`, `colData`, and `t2g` (with quick validators). *Start here if your data isn’t in SE format yet.*

-   **Stepwise Workflow (`sigCor` → GSEA → plots)** - Runs correlation and enrichment separately so you can inspect/modify `cor.df`, change ranking metrics, or swap enrichment settings. *Use for advanced customization.*

-   **Visualization Functions** - What each SigFun plotting function does (bar, dot, heat, cnet, emap, tree, ridge, lollipop, UpSet, gsea, chord diagram) with concise usage examples. *Use when crafting publication figures.*

-   **Custom Gene Ranking** - Plug in your own gene-level stats (e.g., `log2FC`, `zscore`) by attaching a `cor.df` and setting `ranking.method`. *Use when you already computed rankings externally.*

# QuickStart Workflow (Streamlined)

## Installation & Load Package

To install `SigFun`, ensure that you have R 4.4.0 or later installed (see the R Project at <http://www.r-project.org>) and are familiar with its usage.

`SigFun` package is also available on GitHub repository <https://github.com/BioinfOMICS/SigFun>. Before installing `SigFun`, you must first install the core Bioconductor packages. If you have already installed them, you can skip the following step.

```{r install_Bioconductor, eval=FALSE}
if (!requireNamespace("BiocManager", quietly=TRUE))
    install.packages("BiocManager")
BiocManager::install()
```

Once the core Bioconductor packages are installed, you can proceed with installing `SigFun`.

```{r install_package, eval=FALSE}
## Update repositories
options(repos = c(
    CRAN = "https://cloud.r-project.org/",
    BiocManager::repositories()))

## Install dependencies and package
devtools::install_github(
    "BioinfOMICS/SigFun", 
    build_vignettes = TRUE, dependencies = TRUE)
```

After the installation is complete, you are ready to start using `SigFun`. Now, let’s load the package first.

```{r load_packages, message=FALSE}
library(SigFun)
library(dplyr)
library(DT)
```

## Quick Setup Checklist

-   **Input container:** a `SummarizedExperiment` (SE) with

    -   `assay$abundance`: genes x samples expression matrix (numeric; no columns or rows should contain all values of `NA`)

    -   rowData: gene annotations (must align row-order with `assays`)

    -   colData: sample metatdata (includes your signature columns[s])

-   **Ontology:** a two-column `t2g` data.frame with `gs_name`, `ensembl_gene` (ID type should match `rowData$ensg_id`). (For setup, refer to [Ontology Database Setup])

-   **Method selection:**

    -   numeric signature → `cor.method = "spearman"` (default) or `"pearson"/"kendall"`

    -   binary signature (0/1) → `cor.method = "logit"`

## Load Demo Data

```{r load_demo_data}
# Demo resources bundled with SigFun
data("expr.data") # expression matrix (genes × samples)
data("mapping") # gene annotations with Ensembl IDs
data("SIG_MAT") # sample metadata incl. demo signatures
data("t2g") # ontology (TERM2GENE)
```

## Build a `SummarizedExperiment`

**Note:** See the *Data Preparation vignette* for more details.

```{r build_a_summarizedExperiment}
SE_demo <- SummarizedExperiment::SummarizedExperiment(
  assays = list(abundance = as.matrix(expr.data)),
  rowData = S4Vectors::DataFrame(mapping, row.names = mapping$ensg_id),
  colData = S4Vectors::DataFrame(SIG_MAT)
)

SE_demo
```

**Sanity checks (optional but recommended)**

```{r sanity_checks}
stopifnot(
  is.matrix(SummarizedExperiment::assay(SE_demo, "abundance")),
  is.numeric(SummarizedExperiment::assay(SE_demo, "abundance")),
  # No rows should be entirely NA
  all(rowSums(is.na(SummarizedExperiment::assay(SE_demo, "abundance"))) < ncol(SummarizedExperiment::assay(SE_demo, "abundance"))),
  # No columns should be entirely NA
  all(colSums(is.na(SummarizedExperiment::assay(SE_demo, "abundance"))) < nrow(SummarizedExperiment::assay(SE_demo, "abundance"))),
  # Row names must match ensg_id column
  all(rownames(SummarizedExperiment::rowData(SE_demo)) == SummarizedExperiment::rowData(SE_demo)$ensg_id),
  # Column names must match sample identifiers in colData
  all(colnames(SummarizedExperiment::assay(SE_demo, "abundance")) == rownames(SummarizedExperiment::colData(SE_demo))),
  # Dimensions must match
  nrow(SummarizedExperiment::assay(SE_demo, "abundance")) == nrow(SummarizedExperiment::rowData(SE_demo)),
  ncol(SummarizedExperiment::assay(SE_demo, "abundance")) == nrow(SummarizedExperiment::colData(SE_demo))
)
```

## (Optional) Use a Custom Ranking

If you already computed a metric (e.g., `log2FC`, `zscore`), attach it as `metadata(SE)$cor.df` and point `ranking.method` to that column.

**Note:** See the *Custom Gene Ranking vignette* for more details.

```{r custom_ranking, eval=FALSE}
# This following codes are not ran. Use your own metrics.
custom <- S4Vectors::metadata(SE_demo)$cor.df    # Use your own metric
# Example: create a signed –log10 p
custom <- cor.df %>% dplyr::mutate(signed_logp = sign(cor) * -log10(pval))
S4Vectors::metadata(SE_demo)$cor.df <- custom

SE_res2 <- sig2Fun(SE_demo, t2g = t2g, rankingMethod = "signed_logp", strings = "KEGG")
```

## (Optional) Speed up with KEGG (used only for demonstration)

```{r subset_t2g_to_kegg_terms}
# Smaller ontology for quick runs
t2g_kegg <- t2g %>% 
  dplyr::filter(grepl("^KEGG", gs_name)) %>% 
  dplyr::distinct(gs_name, ensembl_gene)
length(unique(t2g_kegg$gs_name))
```

## Run `sig2Fun()`

Choose `cor.method` based on your signature type. The demo data has binary signatures, thus, we will use `"logit"` to calculate genome-wide associations.

**Method selection options:**

-   **Numeric signatures:** `cor.method = "spearman"` (default), `"pearson"`, or `"kendall"`

-   **Binary Signatures:** `cor.method = "logit"`

**Important Note:** The `strings` parameter in `sig2Fun()` controls which **heatmaps** are automatically generated, not which database are analyzed. In this example, we have already restricted `t2g` to **KEGG**, so all enrichment results correspond exclusively to KEGG pathways regardless of the value of `strings`.

```{r run_streamlined_function, fig.alt="Heatmap of KEGG signature activity across samples produced by sig2Fun()"}
SE_res <- sig2Fun(
  SE_demo,
  t2g = t2g_kegg, # use KEGG subset here
  corMethod = "logit", # for binary signatures
  strings = c("KEGG") # used for heatmap plotting
)
```

**Under the hood objects**

```{r other_objects}
cor.df <- S4Vectors::metadata(SE_res)$cor.df
GSEA_result <- S4Vectors::metadata(SE_res)$gseaResult
head(cor.df)
```

## View Results

**Correlation Table**

```{r Correlation table}
# GSEA table preview
S4Vectors::as.data.frame(GSEA_result) %>%
  dplyr::select(ID, Description, NES, pvalue, p.adjust, qvalue) %>%
  DT::datatable(options = list(pageLength = 10, scrollX = TRUE), rownames = FALSE)
```

**Top Pathways by NES**

```{r Top Pathways by NES}
GSEA_df <- S4Vectors::as.data.frame(GSEA_result)
# Top positively associated
GSEA_df %>% 
  dplyr::filter(grepl("KEGG", ID)) %>% 
  dplyr::arrange(dplyr::desc(NES)) %>%
  dplyr::select(ID, Description, NES, pvalue, p.adjust) %>%
  DT::datatable(options = list(pageLength = 10, scrollX = TRUE), rownames = FALSE)
# Top negatively associated
GSEA_df %>% 
  dplyr::filter(grepl("KEGG", ID)) %>% 
  dplyr::arrange(NES) %>%
  dplyr::select(ID, Description, NES, pvalue, p.adjust) %>%
  DT::datatable(options = list(pageLength = 10, scrollX = TRUE), rownames = FALSE)
```

**Heatmap Visualization**

```{r heatmap}
# Access precomputed heatmaps (keys follow the 'strings' you provided)
All_heatmaps <- S4Vectors::metadata(SE_res)$heatmap
All_heatmaps$KEGG
```

| **Interpreting the Heatmap**
| The heatmap displays the most significant pathways associated with your signature, organized into four panels:
| **1. NES Barplot (left)** – Shows the strength and direction of pathway enrichment (positive = up-regulated, negative = down-regulated)
| **2. Statistical Summary (middle-left)** – Lists NES values with corresponding p-values
| **3. Enrichment Plot (middle-right)** – Shows how pathway genes are distributed across the ranked gene list (standard GSEA plot)
| **4. Pathway Names (right)** – Official pathway descriptions

**Additional Visualizations**: Beyond the default heatmap, SigFun includes 11 other plot types (dot plots, networks, ridge plots, etc.) for exploring results from different perspectives. The results object returned by `sig2Fun()` can be directly used to generate these additional visualizations. See the *Visualization Functions* vignette for examples.

# Workflow Overview

A **SigFun analysis** links a gene signature to its underlying biology through four main stages, from raw expression data to interpretable functional output. The framework is built to accommodate both rapid exploration and detailed customization.

## Core Analysis Stages

1.  **Data Input** - Provide a `SummarizedExperiment` containing:
    -   an expression matrix (`assay`)
    -   feature metadata (`rowdata`)
    -   sample metadata (`colData`) with the signature variable of interest.
2.  **Association Calculation** - SigFun computes genome-wide associations between each gene and the signature score, generating a comprehensive correlation table (`cor.df`).
    -   Continuous signatures → correlation (Spearman/Pearson/Kendall)
    -   Binary signatures → logistic regression
3.  **Functional Enrichment** — The ranked gene list (based on association strength or a custom ranking metric) is tested against pathway databases to identify functions enriched in signature-associated genes.
4.  **Visualization & Interpretation** — Explore and summarize results using 12 integrated visualization functions: pathway networks, heatmaps, ridge plots, lollipop plots, chord diagrams, and more.

## Two Execution Modes

SigFun can be run in two ways depending on your needs:

| Mode | Description | When to Use |
|------------------------|------------------------|------------------------|
| Streamlined | Runs association → enrichment → plotting in one step. Automatically produces ranked tables and core visualizations. | Most users; fast exploration or validation runs |
| Stepwise | Runs each stage separately, allowing inspection or modification of intermediate results (e.g., adding custom ranking metrics, using alternative enrichment methods). | Advanced customization, benchmarking, or method development |

**Note:** This QuickStart vignette uses the **streamlined** mode.

# Appendices

## Ontology Database Setup

```{r t2g_prepare, warning=FALSE, eval=FALSE}
# Prepare gene ontology data. We strongly recommend MsigDB.
# The following code can help you to 
if (!require(msigdbr, quietly = TRUE)) {
  install.packages("msigdbr")
  library(msigdbr)
}
# Download human HALLMARKER ontology information
H_t2g <- msigdbr::msigdbr(species = "Homo sapiens", category = "H") %>% 
  dplyr::select(gs_name, ensembl_gene)

# Download human C2 pathway information
C2_t2g <- msigdbr::msigdbr(species = "Homo sapiens", category = "C2") %>% 
  dplyr::filter(gs_subcat %in% c("CP:BIOCARTA","CP:KEGG_MEDICUS",
      "CP:REACTOME","CP:WIKIPATHWAYS")) %>% 
  dplyr::select(gs_name, ensembl_gene)
# Download human C5 ontology information
C5_t2g <- msigdbr::msigdbr(species = "Homo sapiens", category = "C5") %>% 
  dplyr::filter(gs_subcat %in% c("GO:BP","GO:CC","GO:MF")) %>% 
  dplyr::select(gs_name, ensembl_gene)

# Combine them
t2g <- rbind(H_t2g, C2_t2g, C5_t2g)
```

## Session Information

```{r sessionInfo, echo=FALSE}
sessionInfo()
```
